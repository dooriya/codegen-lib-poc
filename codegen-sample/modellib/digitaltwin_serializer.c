/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.8.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: 3/23/2020
 ***********************************************************************************************/

/**
 * @file digitaltwin_serializer.c
 * @brief Implements APIs to serialize and deserialize data from JSON format. The file relies on
 * the parson C library to handle the JSON serialization and deserialization. Supports all primitive
 * data types (e.g. integer, string, boolean), Enum and Object scheme defined in DTDL (http://aka.ms/dtdl).
 * Other complex data schemas, like Array, nested Object, Map are not supported currently.
 */

#include <string.h>
#include "digitaltwin_serializer.h"
#include "parson.h"

/* Serialize telemetry data */

digitaltwin_serializer_result pocsensor_location_to_json(pocsensor_location * location, char * out_buffer, size_t max_size)
{
    if (location == NULL || out_buffer == NULL)
    {
        return DIGITALTWIN_SERIALIZER_NULL_PASSEDIN;
    }

    memset(out_buffer, 0, max_size);

    JSON_Value * root_value = json_value_init_object();
    JSON_Object * root_object = json_value_get_object(root_value);

    json_object_set_number(root_object, "latitude", location->latitude);
    json_object_set_number(root_object, "longitude", location->longitude);

    char * json_string = json_serialize_to_string(root_value);
    if (json_string == NULL)
    {
        printf("Error: Call json_serialize_to_string failed");
        return DIGITALTWIN_SERIALIZER_INTERNAL_FAILURE;
    }

    size_t needed_size = strlen(json_string);
    if (needed_size > max_size - 1)
    {
        printf("Error: Failed to build location payload string");
        return DIGITALTWIN_SERIALIZER_BUFFER_OVERFLOW;
    }
    else
    {
        memcpy(out_buffer, json_string, needed_size);
        free(json_string);
    }

    json_value_free(root_value);

    return DIGITALTWIN_SERIALIZER_OK;
}

/* Serialize reported property value */

digitaltwin_serializer_result pocsensor_battery_remaining_to_json(double * battery_remaining, char * out_buffer, size_t max_size)
{
    if (battery_remaining == NULL || out_buffer == NULL)
    {
        return DIGITALTWIN_SERIALIZER_NULL_PASSEDIN;
    }

    memset(out_buffer, 0, max_size);
    size_t needed_size = (size_t)snprintf(NULL, 0, "%f", *battery_remaining);

    if (needed_size > max_size - 1)
    {
        printf("Error: Failed to build battery_remaining payload string");
        return DIGITALTWIN_SERIALIZER_BUFFER_OVERFLOW;
    }
    else
    {
        snprintf(out_buffer, max_size, "%f", *battery_remaining);
    }

    return DIGITALTWIN_SERIALIZER_OK;
}

/* Serialize command response data */

digitaltwin_serializer_result pocsensor_update_firmware_response_to_json(bool * response, char* out_buffer, size_t max_size)
{
    if (out_buffer == NULL)
    {
        return DIGITALTWIN_SERIALIZER_NULL_PASSEDIN;
    }

    memset(out_buffer, 0, max_size);

    size_t needed_size = (size_t)snprintf(NULL, 0, "%s", *response ? "true" : "false");

    if (needed_size > max_size - 1)
    {
        printf("Error: Failed to build updateFirmware response payload string");
        return DIGITALTWIN_SERIALIZER_BUFFER_OVERFLOW;
    }
    else
    {
        snprintf(out_buffer, max_size, "%s", *response ? "true" : "false");
    }

    return DIGITALTWIN_SERIALIZER_OK;
}

/* Deserialize desired property value */

digitaltwin_serializer_result pocsensor_settings_from_json(pocsensor_settings * desiredValue, const char * data_buffer, size_t size)
{
    (void)size;

    // Parse payload string and set desired property.
    JSON_Value * jsonValue = json_parse_string((const char*)data_buffer);

    JSON_Object *jsonObject = json_value_get_object(jsonValue);
    bool isTypeValid = (json_value_get_type(jsonValue) == JSONObject);
    if (isTypeValid)
    {
        desiredValue->fanSpeed = (double)json_object_get_number(jsonObject, "fanSpeed");

        desiredValue->voltage = (double)json_object_get_number(jsonObject, "voltage");

    }
    else
    {
        printf("Error: Invalid desired value for settings, value schema should be Object");
        return DIGITALTWIN_SERIALIZER_INVALID_TYPE;
    }

    json_value_free(jsonValue);

    return DIGITALTWIN_SERIALIZER_OK;
}

/* Deserialize command request data */

digitaltwin_serializer_result pocsensor_update_firmware_request_from_json(pocsensor_update_firmware_request * requestData, const char * data_buffer, size_t size)
{
    (void)size;

    // Parse request data from cloud.
    JSON_Value * jsonValue = NULL;
    jsonValue = json_parse_string((const char*)data_buffer);
    if (jsonValue == NULL)
    {
        return DIGITALTWIN_SERIALIZER_NULL_PASSEDIN;
    }

    JSON_Object * jsonObject = json_value_get_object(jsonValue);

    const char * firmware_uriStr = (const char*)json_object_get_string(jsonObject, "firmware_uri");
    if (firmware_uriStr != NULL)
    {
        size_t firmware_uriStrLen = strlen(firmware_uriStr);

        if (requestData->firmware_uri != NULL)
        {
            free(requestData->firmware_uri);
            requestData->firmware_uri = NULL;
        }

        requestData->firmware_uri = (char *)malloc(firmware_uriStrLen + 1);
        if (requestData->firmware_uri != NULL)
        {
            strncpy(requestData->firmware_uri, firmware_uriStr, firmware_uriStrLen);
        }
        else
        {
            return DIGITALTWIN_SERIALIZER_OUT_OF_MEMORY;
        }
    }

    requestData->firmware_version = (int)json_object_get_number(jsonObject, "firmware_version");

    if (jsonValue)
    {
        json_value_free(jsonValue);
    }

    return DIGITALTWIN_SERIALIZER_OK;
}
