/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.8.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: 3/23/2020
 ***********************************************************************************************/

#include <stdio.h>
#include <stdlib.h>

#include "digitaltwin_client_helper.h"

// Amount to sleep between querying state from the register interface loop
static const int RegisterInterfacePollSleep = 100;

// Maximum amount of times we'll poll for interface being ready.  Current defaults between this and
// 'RegisterInterfacePollSleep' means we'll wait up to a minute for interface registration.
static const int RegisterInterfaceMaxPolls = 600;

static IOTHUB_DEVICE_CLIENT_LL_HANDLE deviceHandle = NULL;
static DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE dt_device_client_handle = NULL;

static bool az_dt_client_set_option(const char* optionName, const void* value)
{
    if (deviceHandle == NULL || optionName == NULL || value == NULL)
    {
        return false;
    }

    IOTHUB_CLIENT_RESULT iothubClientResult;

    if ((iothubClientResult = IoTHubDeviceClient_LL_SetOption(deviceHandle, optionName, value)) != IOTHUB_CLIENT_OK)
    {
        LogError("Failed to set option %s, error=%d", optionName, iothubClientResult);
        IoTHubDeviceClient_LL_Destroy(deviceHandle);
        deviceHandle = NULL;

        IoTHub_Deinit();
        return false;
    }
    else
    {
        return true;
    }
}

DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE az_dt_client_init_device_handle(const char* device_connection_string, bool trace_on, const char * trustedCert)
{
    DIGITALTWIN_CLIENT_RESULT result;
    bool urlEncodeOn = true;
    deviceHandle = NULL;

    if (IoTHub_Init() != 0)
    {
        LogError("IoTHub_Init failed");
    }
    else
    {
        // First, we create a standard IOTHUB_DEVICE_HANDLE handle for DigitalTwin to consume.
        if ((deviceHandle = IoTHubDeviceClient_LL_CreateFromConnectionString(device_connection_string, MQTT_Protocol)) == NULL)
        {
            LogError("Failed to create device handle");
            IoTHub_Deinit();
            return NULL;
        }

        az_dt_client_set_option(OPTION_LOG_TRACE, &trace_on);
        az_dt_client_set_option("product_info", "pnp_codegen_v0.6.8");

        // Setting OPTION_AUTO_URL_ENCODE_DECODE is required by callers only for private-preview.  
        // https://github.com/Azure/azure-iot-sdk-c-pnp/issues/2 tracks making underlying DigitalTwin set this automatically.
        az_dt_client_set_option(OPTION_AUTO_URL_ENCODE_DECODE, &urlEncodeOn);

        if (trustedCert != NULL)
        {
            az_dt_client_set_option("TrustedCerts", trustedCert);
        }

        if ((result = DigitalTwin_DeviceClient_LL_CreateFromDeviceHandle(deviceHandle, &dt_device_client_handle)) != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_DeviceClient_LL_CreateFromDeviceHandle failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        }
        else
        {
            // Never log the complete connection string , as this contains information
            // that could compromise security of the device.
            LogInfo("Successfully created DigitalTwin device with device_connection_string=<****>, deviceHandle=<%p>", deviceHandle);
        }
    }

    return dt_device_client_handle;
}

// az_dt_client_interface_registered_callback is invoked when the interfaces have been registered or failed.
// The userContextCallback pointer is set to whether we succeeded or failed and checked by thread blocking
// for registration to complete.
static void az_dt_client_interface_registered_callback(DIGITALTWIN_CLIENT_RESULT digitalTwinInterfaceStatus, void *userContextCallback)
{
    digitaltwin_registration_status* digitalTwinRegistrationStatus = (digitaltwin_registration_status*)userContextCallback;

    if (digitalTwinInterfaceStatus == DIGITALTWIN_CLIENT_OK)
    {
        LogInfo("Interface registration callback invoked, interfaces have been successfully registered");
        *digitalTwinRegistrationStatus = DIGITALTWIN_REGISTRATION_SUCCEEDED;
    }
    else
    {
        LogError("Interface registration callback invoked with an error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinInterfaceStatus));
        *digitalTwinRegistrationStatus = DIGITALTWIN_REGISTRATION_FAILED;
    }
}

DIGITALTWIN_CLIENT_RESULT az_dt_client_register_interface(DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE digitalTwinDeviceHandle, const char* deviceCapabilityModelUri, DIGITALTWIN_INTERFACE_CLIENT_HANDLE* interface_client_handles, int numInterfaceClientHandles)
{
    DIGITALTWIN_CLIENT_RESULT result;
    digitaltwin_registration_status digitalTwinRegistrationStatus = DIGITALTWIN_REGISTRATION_PENDING;

    // Give DigitalTwin interfaces to register. DigitalTwin_DeviceClient_LL_RegisterInterfacesAsync returns immediately
    if ((result = DigitalTwin_DeviceClient_LL_RegisterInterfacesAsync(digitalTwinDeviceHandle, deviceCapabilityModelUri, interface_client_handles, numInterfaceClientHandles, az_dt_client_interface_registered_callback, &digitalTwinRegistrationStatus)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("DigitalTwin_DeviceClient_LL_RegisterInterfacesAsync failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        // After registration, we do a simple polling algorithm to check for whether the callback
        // az_dt_client_interface_registered_callback has changed digitalTwinRegistrationStatus. 
        // Since we can't do any other DigitalTwin operations at this point, we have to block here.
        for (int i = 0; (i < RegisterInterfaceMaxPolls) && (digitalTwinRegistrationStatus == DIGITALTWIN_REGISTRATION_PENDING); i++)
        {
            DigitalTwin_DeviceClient_LL_DoWork(digitalTwinDeviceHandle);
            ThreadAPI_Sleep(RegisterInterfacePollSleep);
        }

        if (digitalTwinRegistrationStatus == DIGITALTWIN_REGISTRATION_SUCCEEDED)
        {
            LogInfo("DigitalTwin interfaces successfully registered");
            result = DIGITALTWIN_CLIENT_OK;
        }
        else if (digitalTwinRegistrationStatus == DIGITALTWIN_REGISTRATION_PENDING)
        {
            LogError("Timed out attempting to register DigitalTwin interfaces");
            result = DIGITALTWIN_CLIENT_ERROR;
        }
        else
        {
            LogError("Error registering DigitalTwin interfaces");
            result = DIGITALTWIN_CLIENT_ERROR;
        }
    }

    return result;
}

void az_dt_client_deinit()
{
    if (dt_device_client_handle != NULL)
    {
        DigitalTwin_DeviceClient_LL_Destroy(dt_device_client_handle);
    }

    if ((dt_device_client_handle == NULL) && (deviceHandle != NULL))
    {
        // Only destroy the deviceHandle directly if we've never created a dt_device_client_handle
        // (dt_device_client_handle de facto takes ownership of deviceHandle once its created).
        IoTHubDeviceClient_LL_Destroy(deviceHandle);
    }

    if (deviceHandle != NULL)
    {
        IoTHub_Deinit();
    }
}
